# Project 6：Google Password Checkup 协议验证

> 参考论文：IACR ePrint 2019/723《Protocols for Checking Compromised Credentials》sec.3.1（单元素私有集合成员查询场景），以及 Google/学术资料对 **k 匿名 + 哈希前缀分桶（bucketization）+ 后缀匹配** 的设计思路。本文实现一个**可运行的最小教学原型**，帮助你完成课程实验与演示。

## 一、目标与思路
- **目标**：客户端想知道自己的凭据 `(user, password)` 是否出现在服务器维护的泄露库中；同时**不泄露**明文 `(user, password)` 给服务器，也**尽量减少**服务器对客户端查询的了解。
- **核心思路（教学实现）**：
  1. 令 `H = SHA-256(user || ":" || password)`。
  2. 用 `prefix = H[:K]`（K=20 位，等价 5 个十六进制字符）做**k 匿名分桶**：客户端**只发送前缀**；服务器返回该桶内所有**后缀集合**或**布隆过滤器**。
  3. 客户端在本地用 `suffix = H[K:]` 做**后缀匹配**，若命中则判定为**已泄露**。
- **可选增强（实验扩展）**：增加“**玩具 OPRF**（基于 RSA 盲化签名）”模式，对后缀再做一次不可识别的变换，降低服务器对后缀分布的了解（仅教学演示，非生产强安全）。


## 二、目录结构
```
project6_password_checkup/
├─ README_CN.md
├─ data/
│  └─ breached_samples.txt（示例泄露库：user:password 每行一条）
├─ server.py（服务器端：构建泄露库、分桶、布隆过滤器、提供查询接口）
├─ client.py（客户端：生成查询前缀、校验后缀或布隆过滤器）
├─ bloom.py（简易布隆过滤器实现，可调误报率）
├─ oprf_rsa.py（可选：教学用 RSA OPRF/盲化演示）
├─ protocol.py（协议常量、哈希封装、工具函数）
└─ demo_run.py（一键演示：基础/k匿名、布隆、OPRF 三种流程）
```

## 三、运行方法
python demo_run.py
运行后会打印：
- **基础 k 匿名分桶** 查询是否命中（无 OPRF、无布隆）；
- **k 匿名 + 布隆过滤器** 模式；
- **k 匿名 + OPRF(玩具) + 布隆** 模式。

## 四、协议与数学表示
- 定义哈希 `H(x) = SHA-256(x)`，令 `cred = user || ":" || password`。
- 计算 `y = H(cred)`。令 `y = (p, s)`，其中 `p` 为 `y` 的前 K 位（桶号），`s` 为剩余位（后缀）。
- 服务器端对泄露库中每条 `(user_i, pw_i)` 计算 `y_i` 并按 `p_i` 分桶，桶内保存 `s_i` 集合或映射到布隆过滤器 `B_p`。
- **基础查询**：客户端发送 `p`；服务器返回桶 `p` 的 `S_p = {s_i}` 或 `B_p`；客户端检查 `s ∈ S_p` 或 `B_p(s)=1`。
- **玩具 OPRF**（RSA 盲化示例）：用服务器 RSA 私钥 `d`、模数 `N`；客户端将 `s` 盲化为 `s' = s · r^e mod N`，服务器返回 `t' = (s')^d mod N`；客户端解盲得 `t = s^d mod N`，再对 `t` 哈希得到标准化后缀标签。服务器对桶内后缀也做同样变换/标签，返回标签集合或布隆。匹配标签而非明文后缀，减小统计泄露。**注意**：这是教学级 OPRF，真实系统会采用更强的 EC-OPRF 与防滥用策略。

## 五、复杂度与误报
- 桶大小与 `K` 成反比，`K=20`（约百万分之一本桶 2^20）在公开实现中较常见；
- 布隆过滤器误报率 `p ≈ (1 - e^{-kn/m})^k`，本实现允许指定 `m, k` 或通过 `n` 与目标误报率自动估计参数；
- OPRF 模式会增加一次往返与指数运算，属可选扩展。

## 六、实验报告要点
1. **安全性**：客户端仅暴露桶号 `p`；服务器仅知“查询属于桶 p”，不能确定具体凭据；布隆进一步压缩数据；OPRF 让后缀呈伪随机标签。  
2. **隐私泄露**：泄露 `p`（K 位）；返回桶大小可能泄露分布，可通过定长填充/速率限制缓解。  
3. **性能评测**：改变 `K`（如 16, 20, 24 位）、改变布隆误报率（1e-3, 1e-4），记录带宽与误报影响。  
4. **对比**：与直接下载整库、或与无桶 PSI 对比说明实际可用性。  
5. **总结**：k 匿名 + 后缀匹配是易落地方案；OPRF/PSI 能进一步增强隐私但成本更高。

## 参考
- Google 团队密码泄露告警与协议（USENIX Security 2019）：“Protecting accounts from credential stuffing with password breach alerting.”  
- Bucketization/k 匿名与 C3 框架综述：Cornell RSec “Protocols for Checking Compromised Credentials” 幻灯与论文。

