# Project 5 · SM2 软件实现与优化

> 目标：给出 **可运行的 SM2 基础实现**，在此基础上做 **运算优化**，并结合课堂 PPT 指南完成**签名算法误用的 POC 验证**，最后附上**实验总结**。

## 目录结构
```
project5_sm2/
 ├─ README.md                      # 说明文档（含数学推导与实验总结）
 ├─ sm2_baseline.py                # 朴素实现（仿射坐标，便于理解）
 ├─ sm2_opt.py                     # 优化实现（Jacobian + wNAF + 预计算）
 ├─ sm2_kdf.py                     # 简单KDF与杂项工具
 ├─ sm2_pocs.py                    # 签名误用/攻击 POC（仅用于教学）
 ├─ bench.py                       # 简单性能对比脚本
 └─ demo_run.py                    # 一键演示：生成密钥、签名/验签、性能对比、POC
```

## 快速开始
```bash
python demo_run.py
```
运行后会依次输出：
1) 生成密钥对与示例签名/验签；
2) 朴素版 vs 优化版的速度对比；
3) 多个签名误用 POC 的复现与说明。

> 所有脚本 **纯 Python**，仅依赖 `numpy`（用于小规模向量化/计时统计，可去掉）。

---

## 数学与实现要点（简述）

### 1. 椭圆曲线与域参数（SM2 曲线）
素域 \( \mathbb{F}_p \) 上的 Weierstrass 曲线：
\[ y^2 = x^3 + ax + b \]
SM2 推荐曲线参数：
- \( p = 2^{256} - 2^{224} - 2^{96} + 2^{64} - 1 \)
- \( a = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC \)
- \( b = 0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93 \)
- 基点 \( G=(G_x,G_y) \)，阶 \( n \)

**签名/验签**与 ECDSA 同形（但 `ZA` 杂凑等细节不同）。

### 2. 朴素实现（`sm2_baseline.py`）
- 使用仿射坐标，点加/倍点每次都做一次模逆，代码直观、便于核对数学推导。
- 椭圆曲线点运算复杂度较高，但便于作为正确性“基准”。

### 3. 优化实现（`sm2_opt.py`）
- 使用 Jacobian 坐标减少模逆；
- 实现 **wNAF** 编码与 **预计算表**，降低点加次数；
- 固定基点乘（`kG`）与任意点乘（`kP`）分别做策略优化；
- 提供 `fast_sign/fast_verify` 以复用上述加速。

### 4. 签名误用 POC（`sm2_pocs.py`）
覆盖课堂常见误用：
- **复用/相关 `k`**：两笔签名共享 `k` 或线性相关，恢复私钥；
- **弱随机**：`k` 低位泄露/固定前缀，可暴力搜索；
- **没有做范围检查**：未检查 `r,s∈[1,n-1]` 可能导致无效验证通过；
- **消息可控拼接** 与 `ZA` 相关配置错误的影响示例。

### 5. 实验总结
- 朴素版与优化版在 **标量乘** 上相差显著；对于 100 次签名，优化版通常可获得数倍提速；
- 性能瓶颈在大数乘法/平方与点加倍点；Jacobian 坐标与 wNAF 能有效减少“模逆与点加次数”；
- POC 证明：**随机数 `k` 的质量** 是 SM2 安全性的“生命线”，实现必须使用强 `k`（如 RFC6979-风格的确定性方案或可靠 CSPRNG），并严格做 **参数范围检查**。
---
## 参考
- 国家密码管理局 SM2 椭圆曲线公钥密码算法标准
- 课程 PPT（大数运算、Jacobian、wNAF、预计算、常量时实现等）
- SEC1, RFC 6979（确定性 ECDSA 的 k 产生方法，可迁移思想）
